/*--------------------------------------------------------------------------------------------------
 * Portions Copyright (c) YugaByte, Inc.
 * Portions Copyright (c) 1996-2015, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * API for the scanner.
 *
 * The core scanner is also used by PL/pgsql, so we provide a public API
 * for it.  However, the rest of the backend is only expected to use the
 * higher-level API provided by parser.h.
 *--------------------------------------------------------------------------------------------------
 */
#ifndef YB_SQL_PARSER_SCANNER_H
#define YB_SQL_PARSER_SCANNER_H

#include <stdint.h>

/*
 * Keyword representation.
 */
typedef struct ScanKeyword {
  const     char *name;     /* in lower case */
  int16_t   value;          /* grammar's token code */
  int16_t   category;       /* see codes above */
} ScanKeyword;

extern const ScanKeyword ScanKeywords[];
extern const int NumScanKeywords;

/* Keyword categories --- should match lists in gram.y */
#define UNRESERVED_KEYWORD      0
#define COL_NAME_KEYWORD        1
#define TYPE_FUNC_NAME_KEYWORD  2
#define RESERVED_KEYWORD        3

/*
 * We track token locations in terms of byte offsets from the start of the
 * source string, not the column number/line number representation that
 * bison uses by default.  Also, to minimize overhead we track only one
 * location (usually the first token location) for each construct, not
 * the beginning and ending locations as bison does by default.  It's
 * therefore sufficient to make YYLTYPE an int.
 */
#define YYLTYPE  int

// YYSTYPE: Terminal and token data types.
typedef union YbSqlScan_YYSTYPE {
  int64_t       ival;       /* for integer literals */
  char         *str;        /* for identifiers and non-integer literals */
  const char   *keyword;    /* canonical spelling of keywords */
} YbSqlScan_YYSTYPE;

// The YY_EXTRA data that a flex scanner allows us to pass around.
// Private state needed by the core scanner goes here.  Note that the actual
// yy_extra struct may be larger and have this as its first component, thus
// allowing the calling parser to keep some fields of its own in YY_EXTRA.
#define pg_yyget_extra(yyscanner) (*((Parser_extra_type **) (yyscanner)))

typedef struct YbSql_yy_extra_type {
  // The string the scanner is physically scanning.  We keep this mainly so
  // that we can cheaply compute the offset of the current token (yytext).
  char               *scanbuf;
  size_t              scanbuflen;

  // The keyword list to use.
  const ScanKeyword  *keywords;
  int                 num_keywords;

  // Scanner settings to use.  These are initialized from the corresponding
  // GUC variables by scanner_init().  Callers can modify them after
  // scanner_init() if they don't want the scanner's behavior to follow the
  // prevailing GUC settings.
  int                 backslash_quote;
  bool                escape_string_warning;
  bool                standard_conforming_strings;

  // literalbuf is used to accumulate literal values when multiple rules are
  // needed to parse a single literal.  Call startlit() to reset buffer to
  // empty, addlit() to add text.  NOTE: the string in literalbuf is NOT
  // necessarily null-terminated, but there always IS room to add a trailing
  // null at offset literallen.  We store a null only when we need it.
  char               *literalbuf;   /* palloc'd expandable buffer */
  int                 literallen;   /* actual current string length */
  int                 literalalloc; /* current allocated buffer size */

  int                 xcdepth;    /* depth of nesting in slash-star comments */
  char               *dolqstart;    /* current $foo$ quote start string */

  // first part of UTF16 surrogate pair for Unicode escapes.
  int32_t             utf16_first_part;

  // state variables for literal-lexing warnings.
  bool                warn_on_first_escape;
  bool                saw_non_ascii;
} YbSql_yy_extra_type;

// Declare terminal and token types.
typedef union YYSTYPE YbSql_YYSTYPE;

/*
 * The type of yyscanner is opaque outside scan.l.
 */
typedef void *YbSql_yyscan_t;

/*
 * Entry point to scanner. Parser will call this instead of yylex() that was generated by FLEX.
 * This is PostgreSql's workaround to avoid parsing conflicts.
 *
 * Intermediate filter between parser and core lexer (core_yylex in scan.l).
 *
 * This filter is needed because in some cases the standard SQL grammar
 * requires more than one token lookahead.  We reduce these cases to one-token
 * lookahead by replacing tokens here, in order to keep the grammar LALR(1).
 *
 * Using a filter is simpler than trying to recognize multiword tokens
 * directly in scan.l, because we'd have to allow for comments between the
 * words.  Furthermore it's not clear how to do that without re-introducing
 * scanner backtrack, which would cost more performance than this filter
 * layer does.
 *
 * The filter also provides a convenient place to translate between
 * the core_YYSTYPE and YYSTYPE representations (which are really the
 * same thing anyway, but notationally they're different).
 */
int YbSql_yylex(YbSql_YYSTYPE *lvalp, YYLTYPE *llocp, YbSql_yyscan_t yyscanner);


/* Entry points in parser/scan.l */
int YbSqlScan_yylex(YbSqlScan_YYSTYPE *lvalp,
                    YYLTYPE *llocp,
                    YbSql_yyscan_t yyscanner);
YbSql_yyscan_t scanner_init(const char *str,
                            YbSql_yy_extra_type *yyext,
                            const ScanKeyword *keywords,
                            int num_keywords);
void scanner_finish(YbSql_yyscan_t yyscanner);
int scanner_errposition(int location, YbSql_yyscan_t yyscanner);
void scanner_yyerror(const char *message, YbSql_yyscan_t yyscanner);

/*
 * ScanKeywordLookup - see if a given word is a keyword
 *
 * Returns a pointer to the ScanKeyword table entry, or NULL if no match.
 *
 * The match is done case-insensitively.  Note that we deliberately use a
 * dumbed-down case conversion that will only translate 'A'-'Z' into 'a'-'z',
 * even if we are in a locale where tolower() would produce more or different
 * translations.  This is to conform to the SQL99 spec, which says that
 * keywords are to be matched in this way even though non-keyword identifiers
 * receive a different case-normalization mapping.
 */
const ScanKeyword *ScanKeywordLookup(const char *text,
                                     const ScanKeyword *keywords,
                                     int num_keywords);

#endif // YB_SQL_PARSER_SCANNER_H
