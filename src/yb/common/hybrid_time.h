// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

#ifndef YB_COMMON_HYBRID_TIME_H_
#define YB_COMMON_HYBRID_TIME_H_

#include <inttypes.h>
#include "yb/util/status.h"

#include <string>

namespace yb {
// A transaction hybrid time generated by a Clock.
class HybridTime {
 public:
  typedef uint64_t val_type;

  HybridTime() noexcept : v(kInvalidHybridTime.v) {}

  explicit HybridTime(uint64_t val) : v(val) {}

  bool operator ==(const HybridTime &other) const {
    return v == other.v;
  }
  bool operator !=(const HybridTime &other) const {
    return v != other.v;
  }

  // Decode a hybrid time from the given input slice.
  // Mutates the slice to point after the decoded hybrid time.
  // Returns true upon success.
  bool DecodeFrom(Slice *input);

  // Encode the hybrid time to the given buffer.
  void EncodeTo(faststring *dst) const;

  int CompareTo(const HybridTime &other) const;

  std::string ToString() const;

  std::string ToDebugString() const;

  // Returns this hybrid time as an uint64_t
  uint64_t ToUint64() const;

  // Sets this hybrid time from 'value'
  CHECKED_STATUS FromUint64(uint64_t value);

  val_type value() const { return v; }

  bool operator <(const HybridTime& other) const {
    return CompareTo(other) < 0;
  }

  bool operator >(const HybridTime& other) const {
    return CompareTo(other) > 0;
  }

  bool operator <=(const HybridTime& other) const {
    return CompareTo(other) <= 0;
  }

  bool operator >=(const HybridTime& other) const {
    return CompareTo(other) >= 0;
  }

  // An initial transaction hybrid time, higher than min so that we can have
  // a hybrid time guaranteed to be lower than all generated hybrid times.
  static const HybridTime kInitialHybridTime;

  // An invalid transaction hybrid time -- HybridTime types initialize to this variable.
  static const HybridTime kInvalidHybridTime;

  // The maximum hybrid time.
  static const HybridTime kMax;

  // The minimum hybrid time.
  static const HybridTime kMin;

  // Hybrid times are converted to debug strings as <this_string_constant>(<hybrid_time_value>).
  static const char* const kHybridTimeDebugStrPrefix;

 private:

  val_type v;
};
class faststring;

class Slice;

inline int HybridTime::CompareTo(const HybridTime &other) const {
  if (v < other.v) {
    return -1;
  } else if (v > other.v) {
    return 1;
  }
  return 0;
}

inline std::ostream &operator <<(std::ostream &o, const HybridTime &hybridTime) {
  return o << hybridTime.ToString();
}

}  // namespace yb

#endif  // YB_COMMON_HYBRID_TIME_H_
