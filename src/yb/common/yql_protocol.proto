// Copyright (c) YugaByte, Inc.

package yb;

option java_package = "org.yb";

import "yb/common/common.proto";

// This is an internal protocol for communicating YQL operations from a YB client to a tserver.
//
// Reference:
// Cassandra SQL doc - https://docs.datastax.com/en/cql/3.3/cql/cql_reference/cqlCommandsTOC.html
// Usage notes - https://docs.google.com/document/d/1q9i7a9X5rDdTC0q8hNAqo9i9NyDh0n_Fhm5vdzmtBEw

// A YQL value
message YQLValuePB {
  // Note: an absent value means NULL
  oneof value {
    int32 int8_value = 1;  // Note: min int size in protobuf is int32
    int32 int16_value = 2;
    int32 int32_value = 3;
    int64 int64_value = 4;
    float float_value = 5;
    double double_value = 6;
    string string_value = 7;
    bool bool_value = 8;
    int64 timestamp_value = 9;
    bytes binary_value = 10;
    // raw bytes for inet address in network byte order.
    bytes inetaddress_value = 11;
    YQLMapValuePB map_value = 12;
    YQLSeqValuePB set_value = 13;
    YQLSeqValuePB list_value = 14;
    string decimal_value = 15;
    string varint_value = 16;
    string varint_string_value = 17;
    // raw bytes for uuid value.
    bytes uuid_value = 18;
    // raw bytes for timeuuid value.
    bytes timeuuid_value = 19;
  }
}

// Sequence of values used to represent Lists and Sets (and later Tuples)
message YQLSeqValuePB {
  repeated YQLValuePB elems = 1;
}

message YQLMapValuePB {
  repeated YQLValuePB keys = 1;
  repeated YQLValuePB values = 2;
}

// A column value
message YQLColumnValuePB {
  optional int32 column_id = 1;
  optional YQLValuePB value = 2;
}

// An expression in a WHERE condition
message YQLExpressionPB {
  oneof expr {
    YQLValuePB value = 1;
    int32 column_id = 2;
    YQLConditionPB condition = 3;
  }
}

// Condition operators
enum YQLOperator {
  YQL_OP_NOOP = 0;

  // Operators that take one operand.
  YQL_OP_NOT = 1;
  YQL_OP_IS_NULL = 2;
  YQL_OP_IS_NOT_NULL = 3;
  YQL_OP_IS_TRUE = 4;
  YQL_OP_IS_FALSE = 5;

  // Operators that take two operands.
  YQL_OP_EQUAL = 6;
  YQL_OP_LESS_THAN = 7;
  YQL_OP_LESS_THAN_EQUAL = 8;
  YQL_OP_GREATER_THAN = 9;
  YQL_OP_GREATER_THAN_EQUAL = 10;
  YQL_OP_NOT_EQUAL = 11;

  YQL_OP_AND = 12;
  YQL_OP_OR = 13;
  YQL_OP_LIKE = 14;
  YQL_OP_NOT_LIKE = 15;
  YQL_OP_IN = 16;
  YQL_OP_NOT_IN = 17;

  // Operators that take three operands.
  YQL_OP_BETWEEN = 18;
  YQL_OP_NOT_BETWEEN = 19;

  // Operators that take no operand. For use in "if" clause only currently.
  YQL_OP_EXISTS = 20;     // IF EXISTS
  YQL_OP_NOT_EXISTS = 21; // IF NOT EXISTS
}

// A logical condition that evaluates to true/false. Used in the WHERE clause.
message YQLConditionPB {
  optional YQLOperator op = 1;
  repeated YQLExpressionPB operands = 2;
}

// Client type: only CQL client is supported currently
enum YQLClient {
  YQL_CLIENT_CQL = 1;
}

// Paging state for continuing a read request.
//
// For a SELECT statement that returns many rows, the client may specify how many rows to return at
// most in each fetch. This paging state maintains the state for returning the next set of rows of
// the statement. This paging state is opaque to the client.
//
// When there should be more rows to return from the same tablet in the next fetch, "next_row_key"
// is populated in DocDB (YQLReadOperation) with the DocKey of the next row to read. We also embed a
// hybrid-time which is the clean snapshot time for read consistency. We also populate the
// "next_partition_key" for the next row, which is the hash code of the hash portion of the DocKey.
// This next parition key is needed by YBClient (Batcher) to locate the tablet to send the request
// to and it doesn't have access to the DocDB function to decode and extract from the DocKey.
//
// When we are done returning rows from the current tablet and the next fetch should continue in
// the next tablet (possible only for full-table query across tablets), "next_partition_key" is
// populated by the current tablet with its exclusive partition-end key, which is the start key of
// next tablet's partition. "next_row_key" is empty in this case which means we will start from the
// very beginning of the next tablet. (TODO: we need to return the clean snapshot time in this case
// also).
//
message YQLPagingStatePB {
  // Table UUID to verify the same table still exists when continuing in the next fetch.
  optional bytes table_id = 1;

  // Partition key to find the tablet server of the next row to read.
  optional bytes next_partition_key = 2;

  // The row key (SubDocKey = [DocKey + HybridTimestamp]) of the next row to read.
  optional bytes next_row_key = 3;

  // Running total number of rows read across fetches so far. Needed to ensure we read up to the
  // number of rows in the SELECT's LIMIT clause across fetches.
  optional uint64 total_num_rows_read = 4;
}

//-------------------------------------- Write request ---------------------------------------

message YQLWriteRequestPB {

  // Statement types
  enum YQLStmtType {
    YQL_STMT_INSERT = 1;
    YQL_STMT_UPDATE = 2;
    YQL_STMT_DELETE = 3;
  }

  // Statement type
  optional YQLStmtType type = 1; // required

  // Client info
  optional YQLClient client = 2; // required
  optional uint64 request_id = 3; // client request id - for debug tracing purpose only

  // Table schema version
  optional uint32 schema_version = 4; // required

  // Primary key of the row to insert/update/delete - all fields required. The hashed and
  // range column values must be in the same order as the column order in the table schema.
  //
  // Note: the hash_code is the hash of the hashed_column_values. Technically, this can be
  // recomputed by tserver also, but since the client already calculates this to look up the
  // correct tablet server, it is passed in.
  optional uint32 hash_code = 5;
  repeated YQLColumnValuePB hashed_column_values = 6;
  repeated YQLColumnValuePB range_column_values = 7;

  // Column values to insert/update/delete - required
  // Note: DELETE statement has no column value.
  repeated YQLColumnValuePB column_values = 8;

  // If clause condition
  optional YQLConditionPB if_condition = 9;

  // Time to live in millisecondss.
  optional uint64 ttl = 10;
}

//-------------------------------------- Read request ----------------------------------------

message YQLReadRequestPB {

  // Client info
  optional YQLClient client = 1; // required
  optional uint64 request_id = 2; // client request id - for debug tracing purpose only

  // Table schema version
  optional uint32 schema_version = 3; // required

  // Hashed key of row(s) to read - all fields required. The hashed column values must be in the
  // same order as the column order in the table schema. If only a subset of hash columns are
  // specified in the WHERE clause of the SELECT statement, "hashed_column_values" will be empty
  // and we will do a full-table query across tablets.
  optional uint32 hash_code = 4;
  repeated YQLColumnValuePB hashed_column_values = 5;

  // Where clause condition
  optional YQLConditionPB where_condition = 6;

  // Column ids to read (select)
  repeated int32 column_ids = 7; // required
  // Reading distinct columns?
  optional bool distinct = 12 [default = false];

  // Limit number of rows to return. For YQL SELECT, this limit is the smaller of the page size (max
  // (max number of rows to return per fetch) & the LIMIT clause if present in the SELECT statement.
  optional uint64 limit = 8;

  // Paging state retrieved from the last response.
  optional YQLPagingStatePB paging_state = 10;

  // Return paging state when "limit" number of rows are returned? In case when "limit" is the
  // page size, this is set for YQLResponsePB to return the paging state for the next fetch.
  optional bool return_paging_state = 11 [default = false];
}

//------------------------------ Response (for both read and write) -----------------------------

message YQLResponsePB {

  // Response status
  enum YQLStatus {
    YQL_STATUS_OK = 0;
    YQL_STATUS_SCHEMA_VERSION_MISMATCH = 1;
    YQL_STATUS_RUNTIME_ERROR = 2;
  }

  // Status and error message
  optional YQLStatus status = 1 [ default = YQL_STATUS_OK ]; // required
  optional string error_message = 2;

  // Schema of the rows returned if present (used by conditional DML (write) request only
  // as of Jan 2017).
  repeated ColumnSchemaPB column_schemas = 3;

  // Sidecar of rows data returned
  optional int32 rows_data_sidecar = 4;

  // Paging state for continuing the read in the next YQLReadRequestPB fetch.
  optional YQLPagingStatePB paging_state = 5;
}
